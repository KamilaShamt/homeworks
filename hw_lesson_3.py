# -*- coding: utf-8 -*-
"""hw_lesson_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dzmrwlOZt2Ov0Azekylq7nKNKgKzwnX7
"""

# 1. Вам представлен код с реализацией алгоритма Нидлмана-Вунша. Функция needleman_wunsch принимает параметры: match=2, mismatch=-1, gap=-1
# поэксперементируйте с параметрами и посморите, как меняется выравнивание и score. Какие выводы можно сделать?

если увеличить вознаграждение за match, то будет расти score, но в моем примере при 1 и 3 баллах за match глобально не изменилась последовательность
если увеличить штраф за mismatch, то будет падать score,  если mismatch больше, чем gap, то выгоднее вставить gap, чем mismatch
если увеличить штраф за gap, то будет падать score, в данном примере тоже глобально ничего не изменилось

# 2. Используя numpy создайте матрицу 7 на 7
import numpy as np
matrix = np.zeros((7, 7))
print(matrix)

# 3. NumPy: создайтие диагональную матрицу, где по главной диагонали идут числа от 1 до 5

diagonal_elements = np.arange(1, 6)

diagonal_matrix = np.diag(diagonal_elements)

print(diagonal_matrix)

# 4. Напиши функцию, которая принимает матрицу и проверяет, является ли она единичной. В ответе возвращается True или False

def matrixchecker(matrix):

    # определем размер матрицы
    rows, cols = matrix.shape

     #создаем единичную матрицу того же размера
    reference = np.eye(rows)

    # сравниваем матрицы
    return np.array_equal(matrix, reference)

print(checkmatrix(diagonal_matrix))



